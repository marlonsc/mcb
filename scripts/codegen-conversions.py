#!/usr/bin/env python3
"""Generate domain ↔ SeaORM conversion files from config/conversions.toml.

Reads the TOML config and generates one Rust file per entity with:
- From<entity::Model> for DomainType
- From<DomainType> for entity::ActiveModel

Usage: python3 scripts/codegen-conversions.py
"""

import re
import tomllib
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
CONFIG_PATH = ROOT / "config" / "conversions.toml"
OUTPUT_DIR = (
    ROOT / "crates" / "mcb-providers" / "src" / "database" / "seaorm" / "conversions"
)

GENERATED_HEADER = "//! ⚠️ GENERATED by `make codegen-conversions` — DO NOT EDIT\n"
ENTITIES_DIR = (
    ROOT / "crates" / "mcb-providers" / "src" / "database" / "seaorm" / "entities"
)

# Regex to extract `pub field: Type` from SeaORM entity Model structs
_MODEL_FIELD_RE = re.compile(r"^\s*pub\s+(\w+):\s+(.+?)\s*,?\s*$")


def parse_entity_model_fields(entity_module: str) -> dict[str, str]:
    """Parse the SeaORM entity .rs file to extract Model field names and types.

    Returns a dict mapping field_name -> rust_type (e.g. 'String', 'Option<String>', 'i64').
    """
    # Entity files use plural names; the mod.rs re-exports as singular.
    # Read mod.rs to find the mapping: `pub use {plural} as {singular};`
    mod_rs = ENTITIES_DIR / "mod.rs"
    plural_name = entity_module  # fallback
    for line in mod_rs.read_text().splitlines():
        m = re.match(rf"^pub use (\w+) as {re.escape(entity_module)};$", line.strip())
        if m:
            plural_name = m.group(1)
            break

    entity_file = ENTITIES_DIR / f"{plural_name}.rs"
    if not entity_file.exists():
        return {}

    text = entity_file.read_text()
    # Extract the Model struct body
    in_model = False
    brace_depth = 0
    fields: dict[str, str] = {}
    for line in text.splitlines():
        stripped = line.strip()
        if stripped.startswith("pub struct Model"):
            in_model = True
            brace_depth = 0
        if in_model:
            brace_depth += stripped.count("{") - stripped.count("}")
            fm = _MODEL_FIELD_RE.match(line)
            if fm:
                fields[fm.group(1)] = fm.group(2)
            if brace_depth <= 0 and "}" in stripped and in_model and fields:
                break
    return fields


def _test_value_for_field(
    field_name: str,
    db_type: str,
    entity_name: str,
    convert: dict,
    not_set: list[str],
) -> str:
    """Generate a realistic test value for a Model field."""
    conv = convert.get(field_name, {})
    ctype = conv.get("type", "")

    # not_set fields: use None (they're always Option)
    if field_name in not_set:
        return "None"

    is_option = db_type.startswith("Option<")

    # --- Converter-aware values ---
    if ctype == "enum":
        default = conv.get("default", "")
        # Extract the variant string, e.g. "AgentType::Sisyphus" -> "Sisyphus"
        variant_str = default.split("::")[-1] if default else "Default"
        return f'"{variant_str}".into()'

    if ctype == "enum_opt":
        default = conv.get("default", "")
        variant_str = default.split("::")[-1] if default else "Default"
        return f'Some("{variant_str}".into())'

    if ctype == "bool":
        return "1"

    if ctype == "bool_opt":
        return "Some(1)"

    if ctype == "opt_bool":
        return "Some(1)"

    if ctype == "int_cast":
        return "2"

    if ctype == "opt_int_cast":
        return "Some(3)"

    if ctype == "json_array":
        return 'Some(r#"["tag1","tag2"]"#.into())'

    if ctype == "json_array_required":
        return 'r#"["label-a"]"#.into()'

    if ctype == "json_object":
        return 'Some(r#"{"key":"val"}"#.into())'

    if ctype == "json_object_opt":
        return 'Some(r#"{"key":"val"}"#.into())'

    if ctype == "json_value":
        return 'r#"{"test":true}"#.into()'

    if ctype == "unwrap_default":
        return 'Some("test_unwrap".into())'

    if ctype == "computed":
        # Computed fields are NOT in the Model — should not be called
        return '"computed_skip".into()'

    # --- Type-based defaults for direct fields ---
    if is_option:
        inner = db_type[len("Option<"):-1]
        if inner == "String":
            return f'Some("test_{field_name}".into())'
        if inner == "i64":
            if field_name.endswith("_at"):
                return "Some(1_700_000_000)"
            if field_name.endswith("_ms"):
                return "Some(1500)"
            return "Some(1)"
        return f'Some("test_{field_name}".into())'

    # Non-optional types
    if db_type == "String":
        if field_name == "id":
            return f'"{entity_name}_test_001".into()'
        if field_name.endswith("_id"):
            return f'"ref_{field_name}_001".into()'
        if field_name.endswith("_json"):
            return '"{}".into()'
        if field_name.endswith("_hash"):
            return f'"hash_{entity_name}_001".into()'
        if field_name == "email":
            return '"test@example.com".into()'
        if field_name == "url":
            return '"https://example.com/repo".into()'
        if field_name == "slug":
            return f'"test-{entity_name}".into()'
        if field_name == "path" or field_name == "local_path":
            return '"/tmp/test-path".into()'
        return f'"test_{field_name}".into()'

    if db_type == "i64":
        if field_name.endswith("_at"):
            return "1_700_000_000"
        if field_name.endswith("_ms"):
            return "1500"
        if field_name.endswith("_count"):
            return "5"
        if field_name == "confidence":
            return "85"
        if field_name == "priority":
            return "2"
        if field_name == "version_number":
            return "1"
        return "1"

    # Fallback
    return f'"test_{field_name}".into()'


def gen_from_model_field(field: str, convert: dict) -> str:
    conv = convert.get(field)
    if not conv:
        return f"            {field}: m.{field},"

    domain_field = conv.get("domain_field", field)
    ctype = conv["type"]

    if ctype == "enum":
        default = conv["default"]
        enum_type = conv["enum_type"]
        if default:
            return f"            {domain_field}: m.{field}.parse::<{enum_type}>().unwrap_or({default}),"
        return f"            {domain_field}: m.{field}.parse::<{enum_type}>().unwrap_or_default(),"

    if ctype == "enum_opt":
        enum_type = conv["enum_type"]
        default = conv["default"]
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| s.parse::<{enum_type}>().ok())\n"
            f"                .unwrap_or({default}),"
        )

    if ctype == "bool":
        return f"            {domain_field}: m.{field} != 0,"

    if ctype == "bool_opt":
        return f"            {domain_field}: m.{field}.is_some_and(|v| v != 0),"

    if ctype == "opt_bool":
        return f"            {domain_field}: m.{field}.map(|v| v != 0),"

    if ctype == "int_cast":
        return f"            {domain_field}: m.{field} as i32,"

    if ctype == "opt_int_cast":
        return f"            {domain_field}: m.{field}.map(|v| v as i32),"

    if ctype == "json_array":
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| serde_json::from_str(s).ok())\n"
            f"                .unwrap_or_default(),"
        )

    if ctype == "json_array_required":
        return f"            {domain_field}: serde_json::from_str(&m.{field}).unwrap_or_default(),"

    if ctype == "json_object":
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| serde_json::from_str(s).ok())\n"
            f"                .unwrap_or_default(),"
        )

    if ctype == "json_object_opt":
        obj_type = conv["object_type"]
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| serde_json::from_str::<{obj_type}>(s).ok()),"
        )

    if ctype == "json_value":
        return (
            f"            {domain_field}: serde_json::from_str(&m.{field})"
            f".unwrap_or(serde_json::Value::Null),"
        )

    if ctype == "unwrap_default":
        return f"            {domain_field}: m.{field}.unwrap_or_default(),"

    if ctype == "computed":
        return f"            {domain_field}: {conv['from_model']},"

    raise ValueError(f"Unknown converter type: {ctype} for field {field}")


def gen_to_active_field(field: str, convert: dict) -> str | None:
    conv = convert.get(field)
    if not conv:
        return f"            {field}: ActiveValue::Set(e.{field}),"

    domain_field = conv.get("domain_field", field)
    ctype = conv["type"]

    if ctype == "enum" or ctype == "enum_opt":
        if ctype == "enum_opt":
            return f"            {field}: ActiveValue::Set(Some(e.{domain_field}.to_string())),"
        return f"            {field}: ActiveValue::Set(e.{domain_field}.to_string()),"

    if ctype == "bool":
        return f"            {field}: ActiveValue::Set(i64::from(e.{domain_field})),"

    if ctype == "bool_opt":
        return (
            f"            {field}: ActiveValue::Set(Some(i64::from(e.{domain_field}))),"
        )

    if ctype == "opt_bool":
        return (
            f"            {field}: ActiveValue::Set(e.{domain_field}.map(i64::from)),"
        )

    if ctype == "int_cast":
        return f"            {field}: ActiveValue::Set(i64::from(e.{domain_field})),"

    if ctype == "opt_int_cast":
        return (
            f"            {field}: ActiveValue::Set(e.{domain_field}.map(i64::from)),"
        )

    if ctype == "json_array":
        return (
            f"            {field}: ActiveValue::Set(Some(\n"
            f"                serde_json::to_string(&e.{domain_field})"
            f'.unwrap_or_else(|_| "[]".into()),\n'
            f"            )),"
        )

    if ctype == "json_array_required":
        return (
            f"            {field}: ActiveValue::Set(\n"
            f"                serde_json::to_string(&e.{domain_field})"
            f'.unwrap_or_else(|_| "[]".into()),\n'
            f"            ),"
        )

    if ctype == "json_object":
        return (
            f"            {field}: ActiveValue::Set(Some(\n"
            f"                serde_json::to_string(&e.{domain_field})"
            f'.unwrap_or_else(|_| "{{}}".into()),\n'
            f"            )),"
        )

    if ctype == "json_object_opt":
        return (
            f"            {field}: ActiveValue::Set(\n"
            f"                e.{domain_field}\n"
            f"                    .as_ref()\n"
            f"                    .and_then(|oc| serde_json::to_string(oc).ok()),\n"
            f"            ),"
        )

    if ctype == "json_value":
        return (
            f"            {field}: ActiveValue::Set(\n"
            f"                serde_json::to_string(&e.{domain_field}).unwrap_or_default(),\n"
            f"            ),"
        )

    if ctype == "unwrap_default":
        return f"            {field}: ActiveValue::Set(Some(e.{domain_field})),"

    if ctype == "computed":
        return None

    raise ValueError(f"Unknown converter type: {ctype} for field {field}")


def needs_serde_json(convert: dict) -> bool:
    serde_types = {
        "json_array",
        "json_array_required",
        "json_object",
        "json_object_opt",
        "json_value",
    }
    return any(c["type"] in serde_types for c in convert.values())

def gen_test_block(name: str, entity: dict) -> str:
    """Generate #[cfg(test)] mod tests block for round-trip conversion test."""
    domain_type = entity["domain"]
    entity_module = entity["entity"]
    fields = entity.get("fields", [])
    convert = entity.get("convert", {})
    not_set = entity.get("not_set", [])

    # Parse the actual entity Model struct to get field names and types
    model_fields = parse_entity_model_fields(entity_module)
    if not model_fields:
        return ""

    # Determine which fields are computed (not in Model)
    computed_fields = {
        f for f, c in convert.items() if c.get("type") == "computed"
    }

    # Build the sample Model constructor
    sample_lines = []
    for field_name, db_type in model_fields.items():
        if field_name in computed_fields:
            continue
        val = _test_value_for_field(field_name, db_type, name, convert, not_set)
        sample_lines.append(f"            {field_name}: {val},")

    # Determine the assertion field (first field in `fields` list)
    assert_field = fields[0] if fields else list(model_fields.keys())[0]

    lines = [
        "",
        "#[cfg(test)]",
        "mod tests {",
        "    use super::*;",
        "",
        f"    fn sample_{name}() -> {entity_module}::Model {{",
        f"        {entity_module}::Model {{",
    ]
    lines.extend(sample_lines)
    lines.extend([
        "        }",
        "    }",
        "",
        "    #[test]",
        f"    fn round_trip_{name}() {{",
        f"        let model = sample_{name}();",
        f"        let model_val = model.{assert_field}.clone();",
        "",
        "        // Model \u2192 Domain",
        f"        let domain: {domain_type} = model.into();",
        f"        assert_eq!(domain.{assert_field}, model_val);",
        "",
        "        // Domain \u2192 ActiveModel (should not panic)",
        f"        let _active: {entity_module}::ActiveModel = domain.into();",
        "    }",
        "}",
    ])

    return "\n".join(lines)

def all_fields_ordered(entity: dict) -> list[str]:
    """Return fields in safe evaluation order (computed fields first)."""
    fields = list(entity.get("fields", []))
    convert = entity.get("convert", {})
    # Computed fields reference other model fields by borrow (e.g. format!),
    # so they MUST be evaluated before direct fields that move those values.
    computed = [cf for cf in convert if cf not in fields and convert[cf].get("type") == "computed"]
    extra = [cf for cf in convert if cf not in fields and convert[cf].get("type") != "computed"]
    return computed + fields + extra


def gen_conversion_file(name: str, entity: dict) -> str:
    domain_type = entity["domain"]
    entity_module = entity["entity"]
    main_import = entity["import"]
    extra_imports = entity.get("extra_imports", [])
    fields = entity.get("fields", [])
    not_set = entity.get("not_set", [])
    convert = entity.get("convert", {})

    lines = [GENERATED_HEADER, ""]
    lines.append("use sea_orm::ActiveValue;")



    lines.append("")
    lines.append(f"use crate::database::seaorm::entities::{entity_module};")
    lines.append(f"use {main_import};")
    for imp in extra_imports:
        lines.append(f"use {imp};")

    from_model_fields = []
    for f in all_fields_ordered(entity):
        from_model_fields.append(gen_from_model_field(f, convert))

    lines.append("")
    lines.append(f"impl From<{entity_module}::Model> for {domain_type} {{")
    lines.append(f"    fn from(m: {entity_module}::Model) -> Self {{")
    lines.append("        Self {")
    for fline in from_model_fields:
        lines.append(fline)
    lines.append("        }")
    lines.append("    }")
    lines.append("}")

    to_active_fields = []
    for f in all_fields_ordered(entity):
        result = gen_to_active_field(f, convert)
        if result is not None:
            to_active_fields.append(result)
    for ns_field in not_set:
        to_active_fields.append(f"            {ns_field}: ActiveValue::NotSet,")

    lines.append("")
    lines.append(f"impl From<{domain_type}> for {entity_module}::ActiveModel {{")
    lines.append(f"    fn from(e: {domain_type}) -> Self {{")
    lines.append("        Self {")
    for fline in to_active_fields:
        lines.append(fline)
    lines.append("        }")
    lines.append("    }")
    lines.append("}")

    test_block = gen_test_block(name, entity)
    if test_block:
        lines.append(test_block)

    return "\n".join(lines) + "\n"


def gen_mod_rs(names: list[str]) -> str:
    lines = [GENERATED_HEADER, ""]
    for n in sorted(names):
        lines.append(f"pub mod {n};")
    return "\n".join(lines) + "\n"


def main():
    with open(CONFIG_PATH, "rb") as f:
        config = tomllib.load(f)

    entity_names = []

    for name, entity in config.items():
        if not isinstance(entity, dict) or "domain" not in entity:
            continue
        entity_names.append(name)
        content = gen_conversion_file(name, entity)
        out_path = OUTPUT_DIR / f"{name}.rs"
        out_path.write_text(content)
        print(f"  ✓ {name}.rs ({len(content)} bytes)")

    mod_content = gen_mod_rs(entity_names)
    (OUTPUT_DIR / "mod.rs").write_text(mod_content)
    print(f"  ✓ mod.rs ({len(entity_names)} modules)")
    print(f"Generated {len(entity_names)} conversion files")


if __name__ == "__main__":
    main()
