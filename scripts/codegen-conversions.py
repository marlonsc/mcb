#!/usr/bin/env python3
"""Generate domain ↔ SeaORM conversion files from config/conversions.toml.

Reads the TOML config and generates one Rust file per entity with:
- From<entity::Model> for DomainType
- From<DomainType> for entity::ActiveModel

Usage: python3 scripts/codegen-conversions.py
"""


import tomllib
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
CONFIG_PATH = ROOT / "config" / "conversions.toml"
OUTPUT_DIR = (
    ROOT / "crates" / "mcb-providers" / "src" / "database" / "seaorm" / "conversions"
)

GENERATED_HEADER = "//! ⚠️ GENERATED by `make codegen-conversions` — DO NOT EDIT\n"


def gen_from_model_field(field: str, convert: dict) -> str:
    conv = convert.get(field)
    if not conv:
        return f"            {field}: m.{field},"

    domain_field = conv.get("domain_field", field)
    ctype = conv["type"]

    if ctype == "enum":
        default = conv["default"]
        enum_type = conv["enum_type"]
        if default:
            return f"            {domain_field}: m.{field}.parse::<{enum_type}>().unwrap_or({default}),"
        return f"            {domain_field}: m.{field}.parse::<{enum_type}>().unwrap_or_default(),"

    if ctype == "enum_opt":
        enum_type = conv["enum_type"]
        default = conv["default"]
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| s.parse::<{enum_type}>().ok())\n"
            f"                .unwrap_or({default}),"
        )

    if ctype == "bool":
        return f"            {domain_field}: m.{field} != 0,"

    if ctype == "bool_opt":
        return f"            {domain_field}: m.{field}.is_some_and(|v| v != 0),"

    if ctype == "opt_bool":
        return f"            {domain_field}: m.{field}.map(|v| v != 0),"

    if ctype == "int_cast":
        return f"            {domain_field}: m.{field} as i32,"

    if ctype == "opt_int_cast":
        return f"            {domain_field}: m.{field}.map(|v| v as i32),"

    if ctype == "json_array":
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| serde_json::from_str(s).ok())\n"
            f"                .unwrap_or_default(),"
        )

    if ctype == "json_array_required":
        return f"            {domain_field}: serde_json::from_str(&m.{field}).unwrap_or_default(),"

    if ctype == "json_object":
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| serde_json::from_str(s).ok())\n"
            f"                .unwrap_or_default(),"
        )

    if ctype == "json_object_opt":
        obj_type = conv["object_type"]
        return (
            f"            {domain_field}: m\n"
            f"                .{field}\n"
            f"                .as_deref()\n"
            f"                .and_then(|s| serde_json::from_str::<{obj_type}>(s).ok()),"
        )

    if ctype == "json_value":
        return (
            f"            {domain_field}: serde_json::from_str(&m.{field})"
            f".unwrap_or(serde_json::Value::Null),"
        )

    if ctype == "unwrap_default":
        return f"            {domain_field}: m.{field}.unwrap_or_default(),"

    if ctype == "computed":
        return f"            {domain_field}: {conv['from_model']},"

    raise ValueError(f"Unknown converter type: {ctype} for field {field}")


def gen_to_active_field(field: str, convert: dict) -> str | None:
    conv = convert.get(field)
    if not conv:
        return f"            {field}: ActiveValue::Set(e.{field}),"

    domain_field = conv.get("domain_field", field)
    ctype = conv["type"]

    if ctype == "enum" or ctype == "enum_opt":
        if ctype == "enum_opt":
            return f"            {field}: ActiveValue::Set(Some(e.{domain_field}.to_string())),"
        return f"            {field}: ActiveValue::Set(e.{domain_field}.to_string()),"

    if ctype == "bool":
        return f"            {field}: ActiveValue::Set(i64::from(e.{domain_field})),"

    if ctype == "bool_opt":
        return (
            f"            {field}: ActiveValue::Set(Some(i64::from(e.{domain_field}))),"
        )

    if ctype == "opt_bool":
        return (
            f"            {field}: ActiveValue::Set(e.{domain_field}.map(i64::from)),"
        )

    if ctype == "int_cast":
        return f"            {field}: ActiveValue::Set(i64::from(e.{domain_field})),"

    if ctype == "opt_int_cast":
        return (
            f"            {field}: ActiveValue::Set(e.{domain_field}.map(i64::from)),"
        )

    if ctype == "json_array":
        return (
            f"            {field}: ActiveValue::Set(Some(\n"
            f"                serde_json::to_string(&e.{domain_field})"
            f'.unwrap_or_else(|_| "[]".into()),\n'
            f"            )),"
        )

    if ctype == "json_array_required":
        return (
            f"            {field}: ActiveValue::Set(\n"
            f"                serde_json::to_string(&e.{domain_field})"
            f'.unwrap_or_else(|_| "[]".into()),\n'
            f"            ),"
        )

    if ctype == "json_object":
        return (
            f"            {field}: ActiveValue::Set(Some(\n"
            f"                serde_json::to_string(&e.{domain_field})"
            f'.unwrap_or_else(|_| "{{}}".into()),\n'
            f"            )),"
        )

    if ctype == "json_object_opt":
        return (
            f"            {field}: ActiveValue::Set(\n"
            f"                e.{domain_field}\n"
            f"                    .as_ref()\n"
            f"                    .and_then(|oc| serde_json::to_string(oc).ok()),\n"
            f"            ),"
        )

    if ctype == "json_value":
        return (
            f"            {field}: ActiveValue::Set(\n"
            f"                serde_json::to_string(&e.{domain_field}).unwrap_or_default(),\n"
            f"            ),"
        )

    if ctype == "unwrap_default":
        return f"            {field}: ActiveValue::Set(Some(e.{domain_field})),"

    if ctype == "computed":
        return None

    raise ValueError(f"Unknown converter type: {ctype} for field {field}")


def needs_serde_json(convert: dict) -> bool:
    serde_types = {
        "json_array",
        "json_array_required",
        "json_object",
        "json_object_opt",
        "json_value",
    }
    return any(c["type"] in serde_types for c in convert.values())


def all_fields_ordered(entity: dict) -> list[str]:
    """Return fields in safe evaluation order (computed fields first)."""
    fields = list(entity.get("fields", []))
    convert = entity.get("convert", {})
    # Computed fields reference other model fields by borrow (e.g. format!),
    # so they MUST be evaluated before direct fields that move those values.
    computed = [cf for cf in convert if cf not in fields and convert[cf].get("type") == "computed"]
    extra = [cf for cf in convert if cf not in fields and convert[cf].get("type") != "computed"]
    return computed + fields + extra


def gen_conversion_file(name: str, entity: dict) -> str:
    domain_type = entity["domain"]
    entity_module = entity["entity"]
    main_import = entity["import"]
    extra_imports = entity.get("extra_imports", [])
    fields = entity.get("fields", [])
    not_set = entity.get("not_set", [])
    convert = entity.get("convert", {})

    lines = [GENERATED_HEADER, ""]
    lines.append("use sea_orm::ActiveValue;")



    lines.append("")
    lines.append(f"use crate::database::seaorm::entities::{entity_module};")
    lines.append(f"use {main_import};")
    for imp in extra_imports:
        lines.append(f"use {imp};")

    from_model_fields = []
    for f in all_fields_ordered(entity):
        from_model_fields.append(gen_from_model_field(f, convert))

    lines.append("")
    lines.append(f"impl From<{entity_module}::Model> for {domain_type} {{")
    lines.append(f"    fn from(m: {entity_module}::Model) -> Self {{")
    lines.append("        Self {")
    for fline in from_model_fields:
        lines.append(fline)
    lines.append("        }")
    lines.append("    }")
    lines.append("}")

    to_active_fields = []
    for f in all_fields_ordered(entity):
        result = gen_to_active_field(f, convert)
        if result is not None:
            to_active_fields.append(result)
    for ns_field in not_set:
        to_active_fields.append(f"            {ns_field}: ActiveValue::NotSet,")

    lines.append("")
    lines.append(f"impl From<{domain_type}> for {entity_module}::ActiveModel {{")
    lines.append(f"    fn from(e: {domain_type}) -> Self {{")
    lines.append("        Self {")
    for fline in to_active_fields:
        lines.append(fline)
    lines.append("        }")
    lines.append("    }")
    lines.append("}")

    return "\n".join(lines) + "\n"


def gen_mod_rs(names: list[str]) -> str:
    lines = [GENERATED_HEADER, ""]
    for n in sorted(names):
        lines.append(f"pub mod {n};")
    return "\n".join(lines) + "\n"


def main():
    with open(CONFIG_PATH, "rb") as f:
        config = tomllib.load(f)

    entity_names = []

    for name, entity in config.items():
        if not isinstance(entity, dict) or "domain" not in entity:
            continue
        entity_names.append(name)
        content = gen_conversion_file(name, entity)
        out_path = OUTPUT_DIR / f"{name}.rs"
        out_path.write_text(content)
        print(f"  ✓ {name}.rs ({len(content)} bytes)")

    mod_content = gen_mod_rs(entity_names)
    (OUTPUT_DIR / "mod.rs").write_text(mod_content)
    print(f"  ✓ mod.rs ({len(entity_names)} modules)")
    print(f"Generated {len(entity_names)} conversion files")


if __name__ == "__main__":
    main()
