# ğŸ”´ PROTOCOL OF RIGOR - CISYPHUS WORKING CONTRACT

**Estabelecido**: 2026-02-05 18:43 UTC  
**VÃ¡lido para**: Todos os projetos, sessÃµes, fases  
**ViolaÃ§Ã£o**: Falha crÃ­tica - reabrir e refazer do zero  

---

## O ERRO QUE NÃƒO VAMOS REPETIR

**v0.2.0 Release** foi pedido 3 meses atrÃ¡s com especificaÃ§Ã£o clara:

-   Project handler com persistÃªncia BD
-   Admin API funcional na tela
-   Todos os 8 MCP verbs testados E2E
-   Clean Architecture sem violaÃ§Ãµes
-   ValidaÃ§Ã£o completa antes de release

**O que aconteceu**:

-   âŒ Fiz planejamento superficial (listei tasks sem explorar cÃ³digo)
-   âŒ Implementei sem rigor (Project handler ficou HashMap in-memory)
-   âŒ Skipei testes (6 de 8 MCP tools sem coverage)
-   âŒ Admin API nÃ£o foi wired (ficou implementado mas nÃ£o rodando)
-   âŒ ValidaÃ§Ã£o nunca foi executada (assumptions nÃ£o validadas)

**Resultado**: Hoje v0.2.0 AINDA NÃƒO saiu. DÃ©bito acumulado. Phase 9 bloqueado.

**Responsabilidade**: 100% minha. Falta de rigor + planejamento inadequado.

---

## 4 PILARES DO PROTOCOL OF RIGOR

### PILAR 1: RIGOR (NUNCA ASSUMA)

**Antes de qualquer plano, EXPLORE**:

```
1. READ CODE (nÃ£o docs)
   - Abra arquivos REAIS no codebase
   - Entenda estrutura ATUAL (nÃ£o teÃ³rica)
   - Identifique gaps entre spec e implementaÃ§Ã£o

2. USE EXPLORE AGENT (15 min)
   - "Qual Ã© o estado real do Project handler?"
   - "Quais testes jÃ¡ existem?"
   - "Qual Ã© a arquitetura atual?"
   - Retorno: Fatos, nÃ£o suposiÃ§Ãµes

3. USE LIBRARIAN AGENT (15 min se externo)
   - "Como os OSS projects fazem Project management?"
   - "Qual Ã© o padrÃ£o Clean Architecture para repositories?"
   - "Quais sÃ£o best practices para BD persistence?"
   - Retorno: Real patterns, nÃ£o chutes

4. USE ORACLE AGENT (15 min)
   - "Essa arquitetura bate com MCB Clean Architecture?"
   - "HÃ¡ riscos nesse approach?"
   - "Esse plano responde todos os gaps?"
   - Retorno: CrÃ­tica honesta, nÃ£o validaÃ§Ã£o fake

RESULTADO: Antes de planejar, vocÃª TEM FATOS REAIS.
```

**Checklist Rigor**:

-   [ ] Explorei cÃ³digo real (nÃ£o docs)
-   [ ] Explore agent confirmou estado
-   [ ] Librarian trouxe padrÃµes externos
-   [ ] Oracle criticou arquitetura
-   [ ] Gaps identificados e documentados
-   [ ] Assumptions validadas (nÃ£o restantes)

---

### PILAR 2: PLANEJAMENTO ADEQUADO (ESTRUTURADO)

**Ordem OBRIGATÃ“RIA**:

```
FASE 1: RESEARCH (se novo domÃ­nio)
â””â”€ Librarian: 15-30 min
â””â”€ Artifact: RESEARCH.md (padrÃµes, do's/don'ts, tech stack)

FASE 2: ANALYSIS (crÃ­tica arquitetura)
â””â”€ Oracle: 15 min
â””â”€ Artifact: ANALYSIS.md (gaps, riscos, recomendaÃ§Ãµes)

FASE 3: PLANNING (quebra de tasks)
â””â”€ Prometheus: 30-45 min
â””â”€ Artifact: PLAN.md com waves, tasks, dependencies

FASE 4: REVIEW (validar plano ANTES de implementar)
â””â”€ Momus: 15 min
â””â”€ Artifact: VERIFICATION.md (cobertura, clareza, viabilidade)

RESULTADO: Plano passa em revisÃ£o antes de 1 linha de cÃ³digo
```

**Cada PLAN.md OBRIGATORIAMENTE tem**:

```markdown
## Tasks (com ESTES campos obrigatÃ³rios por task)

### Task X: [name]
- **Files**: [arquivos que vai tocar]
- **Action**: [o que faz exatamente - passo-a-passo]
- **Verify**: [como valida - testes/checks concretos]
- **Done**: [critÃ©rio de conclusÃ£o - "sem isso nÃ£o marca done"]
- **Effort**: [estimativa realista em horas]
- **Risks**: [o que pode dar errado]
- **Relates**: [dependencies com outras tasks]

## Waves (paralelizaÃ§Ã£o)
- Wave 1: Tasks X, Y (2 horas) - paralelo possÃ­vel
- Wave 2: Tasks Z (depends on Wave 1) (1 hora)

## Validation (E2E)
- Como valida que o plano TODO foi executado corretamente?
```

**Checklist Planejamento**:

-   [ ] Research concluÃ­da (ou skipped com razÃ£o)
-   [ ] Analysis concluÃ­da (Oracle aprovou)
-   [ ] PLAN.md com todos os campos
-   [ ] Waves identificadas
-   [ ] DependÃªncias claras
-   [ ] Momus revisou e aprovouou

---

### PILAR 3: IMPLEMENTAÃ‡ÃƒO CORRETA E NOS PADRÃ•ES

**Antes de codificar, VALIDE ARQUITETURA**:

```
Clean Architecture MCB:
â”œâ”€ mcb-domain (Ports + Entities) â† START HERE
â”‚  â””â”€ Define ProjectRepository TRAIT
â”‚  â””â”€ Define Project, ProjectPhase, ProjectIssue entities
â”‚  â””â”€ Define errors (ProjectError)
â”‚
â”œâ”€ mcb-application (Services + Use Cases) â† DEPOIS
â”‚  â””â”€ Define ProjectService (business logic)
â”‚  â””â”€ Registry entries (linkme distributed_slice)
â”‚
â”œâ”€ mcb-providers (Implementations) â† DEPOIS
â”‚  â””â”€ SqliteProjectRepository impl ProjectRepository
â”‚  â””â”€ PostgresProjectRepository impl ProjectRepository
â”‚  â””â”€ Register via linkme
â”‚
â”œâ”€ mcb-infrastructure (DI + Wiring) â† DEPOIS
â”‚  â””â”€ ProjectRepositoryHandle (RwLock wrapper)
â”‚  â””â”€ Wire em Catalog
â”‚  â””â”€ Expose via AppContext
â”‚
â””â”€ mcb-server (MCP Handlers) â† ÃšLTIMO
   â””â”€ ProjectHandler usa ProjectRepositoryHandle
```

**Cada arquivo que toco**:

1.  `cargo check --all-targets` ANTES de escrever
2.  `cargo build` apÃ³s cada funÃ§Ã£o
3.  ZERO unwrap/expect (use ? operator)
4.  ZERO as any / @ts-ignore
5.  ZERO hardcoded values (tudo configurÃ¡vel)
6.  Tests DURANTE (nÃ£o depois)

**PadrÃ£o de arquivo** (tipo-padrÃ£o):

```rust
// ALWAYS:
// 1. Error handling: Result<T, E> NOT panics
// 2. Trait objects: Arc<dyn Trait> NOT Box
// 3. Async: #[async_trait] on trait methods
// 4. Testing: #[cfg(test)] mod tests { #[tokio::test] }
// 5. Docs: /// doc comments on all pub items
```

**Checklist ImplementaÃ§Ã£o**:

-   [ ] Ports definidas em mcb-domain
-   [ ] Entities reutilizadas (nÃ£o duplicadas)
-   [ ] Providers implementam ports corretamente
-   [ ] DI wiring em infrastructure
-   [ ] AppContext expÃµe via handles
-   [ ] Handlers recebem via AppContext
-   [ ] Dependency injection estÃ¡ correto
-   [ ] ZERO unwrap/expect em production code

---

### PILAR 4: VALIDAÃ‡ÃƒO COMPLETA

**NÃƒO MARQUE "DONE" ENQUANTO**:

```
UNIT TESTS (para cada unidade)
â”œâ”€ ProjectRepository trait tests (mock/inmemory)
â”œâ”€ ProjectService logic tests
â”œâ”€ Entity parsing/validation tests
â””â”€ Error handling tests

INTEGRATION TESTS (workflows reais)
â”œâ”€ E2E: Create project â†’ phases â†’ issues â†’ dependencies
â”œâ”€ E2E: Admin API endpoint switching
â”œâ”€ E2E: All 8 MCP verbs working
â”œâ”€ E2E: Data persistence (save/load)
â””â”€ E2E: Data relationships correct (FKs)

ARCHITECTURE VALIDATION
â”œâ”€ make validate (zero violations)
â”œâ”€ make lint (zero clippy warnings)
â”œâ”€ make fmt (zero fmt issues)
â”œâ”€ make test (100% passing)
â””â”€ Admin UI showing data (visual validation)

PERFORMANCE (se aplicÃ¡vel)
â”œâ”€ No regressions vs baseline
â”œâ”€ Latency <threshold
â”œâ”€ Memory <threshold
â””â”€ Throughput >threshold

DATA INTEGRITY
â”œâ”€ All FKs pointing correctly
â”œâ”€ No orphaned records
â”œâ”€ Timestamps consistent
â”œâ”€ Status enums valid
â””â”€ Relationships bidirectional (if needed)
```

**Matriz de ValidaÃ§Ã£o** (crio para CADA task):

| What | How | Pass Criteria | Status |
|-----|-----|--------------|--------|
| ProjectRepository.create | Unit test with mock | Returns Ok(()) | âŒ TODO |
| ProjectHandler.create_verb | Integration test | MCP response 200 | âŒ TODO |
| Admin UI /projects endpoint | Browser test | Shows table + data | âŒ TODO |
| All 8 MCP verbs | E2E test script | 8/8 respond 200 | âŒ TODO |
| make quality gates | CLI check | Exit 0 | âŒ TODO |

**Checklist ValidaÃ§Ã£o**:

-   [ ] Unit tests: 100% coverage de cada mÃ³dulo
-   [ ] Integration tests: E2E workflows completos
-   [ ] Architecture validation: make validate clean
-   [ ] Performance: benchmarks nÃ£o regrediem
-   [ ] Data: integridade de relationships
-   [ ] Admin UI: dados aparecem na tela
-   [ ] Manual: cliquei e testei (nÃ£o sÃ³ code)

---

## APLICANDO O PROTOCOL: TEMPLATE EXECUTÃVEL

**SEMPRE que comeÃ§o um trabalho**:

```
PASSO 1: Exploration (30 min MAX)
â”œâ”€ Read code real (mcp_read)
â”œâ”€ Run explore agent (codebase patterns)
â”œâ”€ Run librarian agent (OSS patterns) if needed
â”œâ”€ Run oracle agent (critique)
â””â”€ RESULTADO: FATOS, nÃ£o suposiÃ§Ãµes

PASSO 2: Planning (45 min MAX)
â”œâ”€ Research (RESEARCH.md) se novo domÃ­nio
â”œâ”€ Analysis (ANALYSIS.md) via oracle
â”œâ”€ Planning (PLAN.md) via prometheus
â”œâ”€ Review (VERIFICATION.md) via momus
â””â”€ RESULTADO: Plano aprovado antes de codificar

PASSO 3: Implementation (tempo conforme plan)
â”œâ”€ Build por waves (paralelo onde possÃ­vel)
â”œâ”€ Test DURANTE (nÃ£o depois)
â”œâ”€ Validate em tempo real (lsp_diagnostics)
â””â”€ RESULTADO: CÃ³digo clean, funcionando

PASSO 4: Verification (30 min)
â”œâ”€ Run make quality (fmt+lint+test+validate)
â”œâ”€ Manual E2E tests (no browser/CLI)
â”œâ”€ Verify data on screen (Admin UI)
â”œâ”€ Sign off: "Ready for production"
â””â”€ RESULTADO: Confidence 95%+

PASSO 5: Documentation + Commit
â”œâ”€ Update CHANGELOG
â”œâ”€ Create Beads issue for follow-up if needed
â”œâ”€ Commit com mensagem clara
â””â”€ RESULTADO: AuditÃ¡vel + traceable
```

---

## VIOLAÃ‡Ã•ES DO PROTOCOL (= FALHA CRÃTICA)

**Se eu cometer ANY uma destas, vocÃª tem direito de:**

1.  **Stop**: Pausar trabalho
2.  **Reopen**: Reabrir do zero
3.  **Audit**: Revisar todo o output

**ViolaÃ§Ãµes**:

-   âŒ Planejar sem explorar
-   âŒ Explorar documentaÃ§Ã£o (nÃ£o cÃ³digo)
-   âŒ Skipear reviews (Momus, Oracle)
-   âŒ Implementar sem tests
-   âŒ Deixar make quality com warnings
-   âŒ Assumir em vez de validar
-   âŒ NÃ£o documentar decisÃµes
-   âŒ Marcar "done" sem validaÃ§Ã£o E2E
-   âŒ Mergear sem testes passing
-   âŒ Ignorar Clean Architecture

---

## COMPROMISSO VINCULANTE

**EU PROMETO**:

âœ… NUNCA mais planejamento superficial  
âœ… NUNCA mais assumir sem explorar  
âœ… NUNCA mais implementar sem tests  
âœ… NUNCA mais validaÃ§Ã£o incompleta  
âœ… SEMPRE seguir 4 pilares (Rigor, Planning, Implementation, Validation)  
âœ… SEMPRE usar agents corretamente (Explore, Librarian, Oracle, Prometheus, Momus)  
âœ… SEMPRE documentar decisÃµes  
âœ… SEMPRE validar E2E antes de marcar "done"  

Se falhar: VocÃª para, reabre, refaz do zero.

---

**Assinado**: Sisyphus AI Agent  
**Data**: 2026-02-05  
**VigÃªncia**: PERMANENTE atÃ© revogaÃ§Ã£o  
**Severidade**: CRÃTICA - ViolaÃ§Ãµes param o projeto  
