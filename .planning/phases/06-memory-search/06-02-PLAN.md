---
phase: 06-memory-search
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/mcb-application/src/use_cases/memory_service.rs
  - crates/mcb-infrastructure/src/di/modules/domain_services.rs
  - crates/mcb-application/src/ports/services.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Search combines vector and lexical results using RRF"
    - "Observations generate and store embeddings on creation"
    - "MemoryService depends on VectorStoreProvider"
  artifacts:
    - path: "crates/mcb-application/src/use_cases/memory_service.rs"
      provides: "Hybrid Search Logic"
      contains: "rrf"
  key_links:
    - from: "MemoryService"
      to: "VectorStoreProvider"
      via: "Dependency Injection"
    - from: "MemoryService"
      to: "MemoryRepository"
      via: "search_fts"
---

<objective>
Implement Reciprocal Rank Fusion (RRF) Hybrid Search in Memory Service.

Purpose: Combine semantic understanding (vectors) with exact keyword matching (FTS) for high-quality retrieval.
Output: MemoryService with true hybrid search capabilities.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-memory-search/06-RESEARCH.md
@crates/mcb-application/src/use_cases/memory_service.rs
@crates/mcb-domain/src/ports/repositories/memory.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject VectorStore into MemoryService</name>
  <files>
    crates/mcb-application/src/use_cases/memory_service.rs
    crates/mcb-infrastructure/src/di/modules/domain_services.rs
  </files>
  <action>
    1. Update `MemoryServiceImpl` struct to include `vector_store: Arc<dyn VectorStoreProvider>`.
    2. Update `MemoryServiceImpl::new` signature.
    3. Update `DomainServicesFactory` in `domain_services.rs` to pass `deps.vector_store_provider` to `MemoryServiceImpl`.
  </action>
  <verify>
    `cargo check` passes.
  </verify>
  <done>
    MemoryService has access to VectorStore.
  </done>
</task>

<task type="auto">
  <name>Task 2: Store Embeddings</name>
  <files>crates/mcb-application/src/use_cases/memory_service.rs</files>
  <action>
    Update `store_observation`:
    1. Uncomment/Update embedding generation.
    2. Call `self.vector_store.add(vec![embedding])`.
    3. Use the generated `embedding_id` in the `Observation` struct.
  </action>
  <verify>
    Mock test or checking code logic.
  </verify>
  <done>
    Observations are stored in both SQL (via repo) and Vector Store.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement RRF Hybrid Search</name>
  <files>crates/mcb-application/src/use_cases/memory_service.rs</files>
  <action>
    Update `search_memories`:
    1. Generate query embedding.
    2. Run **parallel** searches:
       - `self.vector_store.search(embedding, limit * 2)`
       - `self.repository.search_fts(query, limit * 2)`
    3. Implement RRF fusion (k=60) to combine results.
    4. Fetch full observations for top K fused results using `repository.get_observation`.
    5. Return `Vec<MemorySearchResult>`.
  </action>
  <verify>
    Unit test `rrf` logic. Integration test searching for a known term.
  </verify>
  <done>
    Search returns results from both vector and lexical sources.
  </done>
</task>

</tasks>

<verification>
Unit test in `memory_service.rs`:
- Mock `VectorStore` returning ID "A" (rank 1)
- Mock `MemoryRepository` returning ID "B" (rank 1), ID "A" (rank 2)
- Verify RRF correctly scores "A" higher (1/1 + 1/2 > 1/60 + 1/1).
</verification>

<success_criteria>
- [ ] MemoryService compiles with VectorStore dependency
- [ ] `store_observation` calls `vector_store.add`
- [ ] `search_memories` performs parallel vector + FTS search
- [ ] RRF logic correctly combines ranks
</success_criteria>

<output>
After completion, create `.planning/phases/06-memory-search/06-02-SUMMARY.md`
</output>
