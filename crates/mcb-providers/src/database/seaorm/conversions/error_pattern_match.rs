//! ⚠️ GENERATED by `make codegen-conversions` — DO NOT EDIT

use sea_orm::ActiveValue;

use crate::database::seaorm::entities::error_pattern_match;
use mcb_domain::entities::memory::ErrorPatternMatch;

impl From<error_pattern_match::Model> for ErrorPatternMatch {
    fn from(m: error_pattern_match::Model) -> Self {
        Self {
            id: m.id,
            pattern_id: m.pattern_id,
            observation_id: m.observation_id,
            confidence: m.confidence,
            matched_at: m.matched_at,
            resolved_at: m.resolved_at,
            solution_applied: m.solution_applied.map(|v| v as i32),
            resolution_successful: m.resolution_successful.map(|v| v != 0),
        }
    }
}

impl From<ErrorPatternMatch> for error_pattern_match::ActiveModel {
    fn from(e: ErrorPatternMatch) -> Self {
        Self {
            id: ActiveValue::Set(e.id),
            pattern_id: ActiveValue::Set(e.pattern_id),
            observation_id: ActiveValue::Set(e.observation_id),
            confidence: ActiveValue::Set(e.confidence),
            matched_at: ActiveValue::Set(e.matched_at),
            resolved_at: ActiveValue::Set(e.resolved_at),
            solution_applied: ActiveValue::Set(e.solution_applied.map(i64::from)),
            resolution_successful: ActiveValue::Set(e.resolution_successful.map(i64::from)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_error_pattern_match() -> error_pattern_match::Model {
        error_pattern_match::Model {
            id: "error_pattern_match_test_001".into(),
            pattern_id: "ref_pattern_id_001".into(),
            observation_id: "ref_observation_id_001".into(),
            confidence: 85,
            solution_applied: Some(3),
            resolution_successful: Some(1),
            matched_at: 1_700_000_000,
            resolved_at: Some(1_700_000_000),
        }
    }

    #[test]
    fn round_trip_error_pattern_match() {
        let model = sample_error_pattern_match();
        let model_val = model.id.clone();

        // Model → Domain
        let domain: ErrorPatternMatch = model.into();
        assert_eq!(domain.id, model_val);

        // Domain → ActiveModel (should not panic)
        let _active: error_pattern_match::ActiveModel = domain.into();
    }
}
