//! ⚠️ GENERATED by `make codegen-conversions` — DO NOT EDIT

use sea_orm::ActiveValue;

use crate::database::seaorm::entities::project_dependency;
use mcb_domain::entities::project::{DependencyType, ProjectDependency};

impl From<project_dependency::Model> for ProjectDependency {
    fn from(m: project_dependency::Model) -> Self {
        Self {
            id: m.id,
            from_issue_id: m.from_issue_id,
            to_issue_id: m.to_issue_id,
            created_at: m.created_at,
            dependency_type: m
                .dependency_type
                .parse::<DependencyType>()
                .unwrap_or(DependencyType::RelatesTo),
        }
    }
}

impl From<ProjectDependency> for project_dependency::ActiveModel {
    fn from(e: ProjectDependency) -> Self {
        Self {
            id: ActiveValue::Set(e.id),
            from_issue_id: ActiveValue::Set(e.from_issue_id),
            to_issue_id: ActiveValue::Set(e.to_issue_id),
            created_at: ActiveValue::Set(e.created_at),
            dependency_type: ActiveValue::Set(e.dependency_type.to_string()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_project_dependency() -> project_dependency::Model {
        project_dependency::Model {
            id: "project_dependency_test_001".into(),
            from_issue_id: "ref_from_issue_id_001".into(),
            to_issue_id: "ref_to_issue_id_001".into(),
            dependency_type: "RelatesTo".into(),
            created_at: 1_700_000_000,
        }
    }

    #[test]
    fn round_trip_project_dependency() {
        let model = sample_project_dependency();
        let model_val = model.id.clone();

        // Model → Domain
        let domain: ProjectDependency = model.into();
        assert_eq!(domain.id, model_val);

        // Domain → ActiveModel (should not panic)
        let _active: project_dependency::ActiveModel = domain.into();
    }
}
